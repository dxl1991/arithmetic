Synchronize语义规范：
  1、进入同步块前，先清空工作内存中的共享变量，从主内存中重新加载（也能实现变量的可见性）
  2、解锁前必须把修改的共享变量同步回主内存
volatile语义规范：
  1、使用volatile变量时，必须重新从主内存加载，并且read、load是连续的
  2、修改volatile变量后，必须立马同步回主内存，并且store、write是连续的

-------------------JVM运行时数据区-------------------
一、线程共享部分
  1、方法区
     存储加载的类信息、常量、静态变量、JIT编译后端代码数据
  2、堆内存
     存放对象实例，几乎所有对象、数组都放这里
     回收判断：引用计数器法、可达性分析算法
二、线程独占部分
  1、虚拟机栈
     线程中方法执行的模型，每个方法执行时，就会在虚拟机中创建一个栈帧，每个方法从调用到执行的过程，就对应着栈帧在虚拟机中从入栈到出栈的过程
     栈帧包括：局部变量表（存放局部变量基础类型值），局部对象的引用，操作数栈（存放临时变量），返回值地址
  2、本地方法栈
     和虚拟机栈类似，虚拟机栈是为执行java方法而准备的。本地方法栈是为虚拟机使用native方法而准备的
  3、程序计数器
     记录cpu执行到字节码指令的位置，线程切换需要

直接内存：JVM之外的内存，开发人员自己分配和回收内存


Lock和synchronized的选择
  1、Lock是接口，而synchronized是java中的关键字
  2、synchronized不会导致死锁，而Lock可能造成死锁现象
  3、Lock可以让等待锁的线程响应中断，而synchronized却不行
  4、通过Lock可以知道有没有成功获得锁，而synchronized却无法办到
  5、Lock可以提供多个线程进行读操作
  6、当竞争资源非常激烈时，Lock的性能要远远大于synchronized

分布式锁实现的几种方案
  1、数据库实现（乐观锁）
  2、基于zookeeper实现
  3、基于redis实现。redis调用lua脚本，原子操作设置key和超时时间。推荐redission包，redis官方jar包

常用的数据库优化方法：
  1、建索引 （like语句用不了索引）
  2、分区表

索引的原理：
  对列值创建排序存储，数据结构={列值、行地址}。在有序的数据列表中就可以利用二分查找快速找到要查找的行地址，在根据地址直接取行数据
  mysql使用B+树存储索引