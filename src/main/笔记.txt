Synchronize语义规范：
  1、进入同步块前，先清空工作内存中的共享变量，从主内存中重新加载（也能实现变量的可见性）
  2、解锁前必须把修改的共享变量同步回主内存
volatile语义规范：
  1、使用volatile变量时，必须重新从主内存加载，并且read、load是连续的
  2、修改volatile变量后，必须立马同步回主内存，并且store、write是连续的

-------------------JVM运行时数据区-------------------
一、线程共享部分
  1、方法区
     存储加载的类信息、常量、静态变量、JIT编译后端代码数据
  2、堆内存
     存放对象实例，几乎所有对象、数组都放这里
     回收判断：引用计数器法、可达性分析算法
     默认比例：老年代占2/3，新时代占1/3（Eden占8/10，s0占1/10，s1占1/10）
     JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。
     因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间
二、线程独占部分
  1、虚拟机栈
     线程中方法执行的模型，每个方法执行时，就会在虚拟机中创建一个栈帧，每个方法从调用到执行的过程，就对应着栈帧在虚拟机中从入栈到出栈的过程
     栈帧包括：局部变量表（存放局部变量基础类型值），局部对象的引用，操作数栈（存放临时变量），返回值地址
  2、本地方法栈
     和虚拟机栈类似，虚拟机栈是为执行java方法而准备的。本地方法栈是为虚拟机使用native方法而准备的
  3、程序计数器
     记录cpu执行到字节码指令的位置，线程切换需要

直接内存：JVM之外的内存，开发人员自己分配和回收内存


Lock和synchronized的选择
  1、Lock是接口，而synchronized是java中的关键字
  2、synchronized不会导致死锁，而Lock可能造成死锁现象
  3、Lock可以让等待锁的线程响应中断，而synchronized却不行
  4、通过Lock可以知道有没有成功获得锁，而synchronized却无法办到
  5、Lock可以提供多个线程进行读操作
  6、当竞争资源非常激烈时，Lock的性能要远远大于synchronized

自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环

分布式锁实现的几种方案
  1、数据库实现（乐观锁）
  2、基于zookeeper实现
  3、基于redis实现。redis调用lua脚本，原子操作设置key和超时时间。推荐redission包，redis官方jar包

常用的数据库优化方法：
  1、建索引 （like语句用不了索引）
  2、分区表

索引的原理：
  对列值创建排序存储，数据结构={列值、行地址}。在有序的数据列表中就可以利用二分查找快速找到要查找的行地址，在根据地址直接取行数据
  mysql使用B+树存储索引

唯一id生成方法：
  1、UUID
  2、数据库自增，分库分表的时候可以设置不同表的起始值和步长不同达到全局唯一的效果
  3、雪花算法
  4、redis
  5、AtomicInteger

弱引用--WeekReference
  当一个对象仅仅被weak reference指向, 而没有任何其他strong reference指向的时候, 如果GC运行, 那么这个对象就会被回收

软引用--SoftReference
  用法和弱引用一样，回收的时候再加一个条件：内存不足的时候才会回收

jvm GC
  Minor GC：清理新生代，Eden区满了会触发一次（把根引用对象复制到s0或者s1区域，并且把对象的分代年龄+1，分带年龄大于15的对象会进入到老年代。可回收对象就直接清理掉）
  Major GC：清理永久代
  Full GC：清理整个堆，包括新生代和老年代
  https://www.cnblogs.com/yuyutianxia/p/8986902.html
  shallow heap：这个对象实际占用的堆大小（ 类定义引用大小 + 父类的成员变量所占的空间 + 当前类的成员变量所占的空间 + 结构体对齐）
  retained heap：如果这个对象被删除了（GC回收掉），能节省出多少内存

mysql索引使用了B+树的数据结构，B+树的每个节点不大于16KB，三层树高就可以存储两千万条数据，B+树的叶子节点用双向链表连接方便>或者<查询
Innodb引擎一定有簇索索引（叶子节点包含了数据）：主键索引（没有的话，mysql会寻找unique列或自动新增一列:_rowid），决定了数据的物理存储结构
非聚集索引（辅助索引）：叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录
联合索引：多个字段组成的索引，节点会按创建索引字段顺序依次比较排序，最左匹配原则（必须第一个字段开始，不能中断）
覆盖索引：select的列全部在联合索引里，所以在联合索引里找到了值就不需要返回主键索引里去取值了，减少回表的过程
explain + sql 可以查看sql的执行过程（扫描多少行，是否用到了索引，是否覆盖索引...）

netty两个线程池作用
  一个负责接受客户端的TCP连接
  一个负责处理I/O相关的读写操作，或执行系统task、定时task。一个线程对应多个链路，一个链路对应一个线程，避免并发
