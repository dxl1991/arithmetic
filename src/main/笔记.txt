Synchronize语义规范：
  1、进入同步块前，先清空工作内存中的共享变量，从主内存中重新加载（也能实现变量的可见性）
  2、解锁前必须把修改的共享变量同步回主内存
volatile语义规范：
  1、使用volatile变量时，必须重新从主内存加载，并且read、load是连续的
  2、修改volatile变量后，必须立马同步回主内存，并且store、write是连续的

-------------------JVM运行时数据区-------------------
一、线程共享部分
  1、方法区
     存储加载的类信息、常量、静态变量、JIT编译后端代码数据
  2、堆内存
     存放对象实例，几乎所有对象、数组都放这里
     回收判断：引用计数器法、可达性分析算法
     默认比例：老年代占2/3，新时代占1/3（Eden占8/10，s0占1/10，s1占1/10）
     JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。
     因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间
二、线程独占部分
  1、虚拟机栈
     线程中方法执行的模型，每个方法执行时，就会在虚拟机中创建一个栈帧，每个方法从调用到执行的过程，就对应着栈帧在虚拟机中从入栈到出栈的过程
     栈帧包括：局部变量表（存放局部变量基础类型值），局部对象的引用，操作数栈（存放临时变量），返回值地址
  2、本地方法栈
     和虚拟机栈类似，虚拟机栈是为执行java方法而准备的。本地方法栈是为虚拟机使用native方法而准备的
  3、程序计数器
     记录cpu执行到字节码指令的位置，线程切换需要

直接内存：JVM之外的内存，开发人员自己分配和回收内存


Lock和synchronized的选择
  1、Lock是接口，而synchronized是java中的关键字
  2、synchronized不会导致死锁，而Lock可能造成死锁现象
  3、Lock可以让等待锁的线程响应中断，而synchronized却不行
  4、通过Lock可以知道有没有成功获得锁，而synchronized却无法办到
  5、Lock可以提供多个线程进行读操作
  6、当竞争资源非常激烈时，Lock的性能要远远大于synchronized

自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环（减少了上下文切换）

synchronized的锁升级:
  对象头里保存了锁的状态：无锁、偏向锁、轻量级锁、重量级锁。锁只能升级不能降级
  1、偏向锁：默认这个锁属于A，当A再次拿锁就直接给他，B来拿锁，发现是偏向A的，就去尝试获取锁，成功了就偏向B，否则升级为轻量级锁。用CAS设置偏向锁
  2、轻量级锁：A获取了锁，B来拿锁，先自旋一段时间，如果自旋完还没拿到锁就升级到重量级锁，B阻塞
  3、重量级锁：A获取了锁，B来拿锁，没拿到就直接阻塞了

分布式锁实现的几种方案
  1、数据库实现（乐观锁）
  2、基于zookeeper实现
  3、基于redis实现。redis调用lua脚本，原子操作设置key和超时时间。推荐redission包，redis官方jar包

常用的数据库优化方法：
  1、建索引
  2、分区表

索引的原理：
  对列值创建排序存储，数据结构={列值、行地址}。在有序的数据列表中就可以利用二分查找快速找到要查找的行地址，在根据地址直接取行数据
  mysql使用B+树存储索引

唯一id生成方法：
  1、UUID
  2、数据库自增，分库分表的时候可以设置不同表的起始值和步长不同达到全局唯一的效果
  3、雪花算法
  4、redis
  5、AtomicInteger

弱引用--WeekReference
  当一个对象仅仅被weak reference指向, 而没有任何其他strong reference指向的时候, 如果GC运行, 那么这个对象就会被回收

软引用--SoftReference
  用法和弱引用一样，回收的时候再加一个条件：内存不足的时候才会回收

jvm GC
  Minor GC：清理新生代，Eden区满了会触发一次（把根引用对象复制到s0或者s1区域，并且把对象的分代年龄+1，分带年龄大于15的对象会进入到老年代。可回收对象就直接清理掉）
  Major GC：清理永久代
  Full GC：清理整个堆，包括新生代和老年代
  https://www.cnblogs.com/yuyutianxia/p/8986902.html
  shallow heap：这个对象实际占用的堆大小（ 类定义引用大小 + 父类的成员变量所占的空间 + 当前类的成员变量所占的空间 + 结构体对齐）
  retained heap：如果这个对象被删除了（GC回收掉），能节省出多少内存
  -XX:SurvivorRatio=6 ，设置的是Eden区与每一个Survivor区的比值，可以反推出占新生代的比值，Eden为6, 两个Survivor为2, Eden占新生代的3/4, 每个Survivor占1/8，两个占1/4

Full GC触发条件：
  1、System.gc()方法的调用。此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC
  2、老年代空间不足。新生代对象转入 或者 创建为大对象、大数组时 发现老年代空间不足
  3、方法区空间不足。CMS GC可避免这个问题
  4、判断当前新生代的对象是否能够全部顺利的晋升到老年代，如果不能，就提早触发一次老年代的收集
  5、CMS GC时出现promotion failed和concurrent mode failure时：进行Minor GC时，survivor space放不下, 对象只能放入老年代，而此时老年代也放不下

如何减少Full GC次数：
  1、尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间（加大新生代的空间，降低Minor GC的频率）
  2、不要创建过大的对象及数组（因为数组需要连续空间）
  3、CMS模式里，Full GC之后额外免费赠送一个碎片整理的过程。XX:+UseCMSCompactAtFullCollection（默认开启的）
     执行多少次不压缩的Full GC后,跟着来一次带压缩的。-XX:CMSFullGCsBeforeCompaction （默认值为0，表示每次Full GC是都进行碎片整理），可降低STW的时间
  4、禁止使用System.gc()方法

CMS收集器：
  过程：初始标记、并发标记、重新标记、并发清除
  缺点：1、对CPU资源敏感。默认启动回收线程数=(CPU数量+3)/4，CPU小于4个的时候，对CPU资源占用较大
       2、无法处理浮动垃圾，并发清除阶段，用户线程会产生新的垃圾，CMS只能下次回收
  -XX:CMSInitiatingOccupancyFraction = 92 ：当老年代内存使用了92%就启用CMS收集。这个值如果设置的太大，那么导致并发清除的时候，预留给用户线程的内存不够，
     会出现Concurrent Mode Failure失败。这时候jvm会启动Serial Old收集器来重新收集老年代，这样停顿的时间就长了

G1（Garbage First）收集器：
  开启选项：-XX:+UseG1GC
  化整为零的思路：将java堆划分为多个大小相等的独立区域（Region）
  可停顿的预测：使用者可以明确指定在M毫秒的时间片段内，GC不超过N毫秒
  维护一个优先级列表，优先回收价值最大的Region
  运作期间不会产生内存空间碎片，收集后能提供连续的可用内存
  过程：初始标记、并发标记、最终标记、筛选回收

mysql索引使用了B+树的数据结构，B+树的每个节点不大于16KB，三层树高就可以存储两千万条数据，B+树的叶子节点用双向链表连接方便>或者<查询
Innodb引擎一定有簇索索引（叶子节点包含了数据）：主键索引（没有的话，mysql会寻找unique列或自动新增一列:_rowid），决定了数据的物理存储结构
非聚集索引（辅助索引）：叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录
联合索引：多个字段组成的索引，节点会按创建索引字段顺序依次比较排序，最左匹配原则（必须第一个字段开始，不能中断）
覆盖索引：select的列全部在联合索引里，所以在联合索引里找到了值就不需要返回主键索引里去取值了，减少回表的过程
explain + sql 可以查看sql的执行过程（扫描多少行，是否用到了索引，是否覆盖索引...）

netty两个线程池作用
  一个负责接受客户端的TCP连接
  一个负责处理I/O相关的读写操作，或执行系统task、定时task。一个线程对应多个链路，一个链路对应一个线程，避免并发

redis慢查询日志：
  slowlog-log-slower-than：慢查询预定阀值
  slowlog-max-len:先进先出队列的长度，超过长度后新日志进入会删除老日志（所以可以定期用slowlog get命令获取日志并保持到mysql里）
  慢查询日志记录的是命令执行时间超过阀值的命令，客户端命令执行时间 = 排队等待时间 + 执行时间 + 网络传输时间
  当客户端命令执行时间过长，排查过程：如果慢查询日志里没有，用redis监控看连接数是否大于最大连接数，看是否RDB占用了很多时间

类加载过程：
  加载-->验证-->准备-->解析-->初始化
  内部类只有在使用的时候才会被加载，可利用这一特性写单例模式（避免过早初始化的问题）
  枚举不能被放射创建

aop 应用场景：日志，事务，权限,参数校验
mybatis的Mapper使用了动态代理创建Dao
静态代理模式：
   接口
   被代理类：实现接口
   代理类：实现接口 + 引用真实类
   这样代理就可以对外提供接口的所有方法（可选择用被代理类实现，或自己实现这些方法）
动态代理模式：
   反射方式实现，避免实现所有接口的所有方法(jdk动态帮我们创建一个类(字节码文件),以$Proxy开头)
   代理类的调用方法
   invoke（Method method）{
      if(method 是需要我自己实现的){
         我就自己实现
         return
      }
      //被代理类去实现
      method.invoke()
   }


class文件的开头是一个魔数：0xCAFEBABE
mybatis分页插件

线程池执行任务流程：
   1 使用核心线程执行
   2 核心线程数满了，放入队列
   3 队列满了，使用临时线程
   4 临时线程数满了，使用拒绝策略

线程池大小设置：
cpu密集型：cup核心数 + 1
io密集型：cup核心数 * 2
实际应用：cup核心数 *（1 + 线程等待时间 / 线程运行时间）