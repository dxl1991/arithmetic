一、网络优化
1、客户端UDP发送绑定端口，解决收不到服务器包的问题
2、采用TCP和UDP双连接切换策略，做容错处理
3、kcp定时器优化

二、线程池优化
1、换掉老的线程池，采用DedicatedThreadPool
2、同一场战斗采用同一个线程池（单线程），可以避免并发问题
3、同一场战斗，不同场景采用同一个定时任务，减少定时任务创建
4、客户端代码采用服务器线程池运行，弃用系统线程池，性能提升不少

三、其他优化
1、匹配服id由匹配服带过来，减少战斗服对redis的操作
2、去掉日志打印获取堆栈信息，减少log消耗
3、客户端与战斗服的所有数据直连交互，避免网关服中转
4、定时器优化，采用单线程循环检测定时器，同一个任务通过设置任务下次执行时间，避免频繁创建任务
5、使用对象池，减少帧数据对象创建，减少GC

四、优化过程
1、统计每个协议发送次数、流量、占总流量的比例，然后压缩120字节以上协议，并且针对消息分析优化
2、jstack -l pid | grep 线程id或名字 -A 20  抓取CPU高的线程执行快照，查看他当前正在执行的代码，然后针对性优化
   jstack -l 13278 | grep Frame-Update -A 10
3、取消一些静态单位buff、技能（因为肯定不会有）列表的遍历，因为空map的遍历也有一定消耗
4、top -Hp 进程id 查看各个线程消耗cpu情况，发现是收发包线程占cpu比较多
5、重写protobuf的编码方式，减少内存拷贝
   优化前：发送数据时，先把proto数据编码转换为字节数组，然后再写入netty的ByteBuf
   优化后：重写proto的编码规则，将proto数据直接写入netty的ByteBuf,减少数组创建dd
6、jmap -histo:live 15808 | grep PlayerHero 查看内存里对象的个数，判断是否有内存泄漏问题
7、统计内存中存活的关键对象个数，并且通过多个指标核对，观察是否存在内存泄漏问题
8、协议包合并发送，减少tpc包个数，从而减少tcp包头占用的流量，据统计一个tcp包头大小为54个字节。同一帧内同一个玩家的协议可以合并发送
   合并：只write不flush
   发送：flush
9、尽量减少小包的发送，比如：单位移除消息，消息体里面只有一个单位id，tcp包头比包体大很多。子弹、掉落物和场景效果这种单位的消失时间都是固定的，就可以不用同步，前后端分别计算消失时间，可以省掉不少流量
10、根据单位类型、游戏阶段，使用不同频率的刷新间隔，减少计算量和数据发送。比如怪物可以刷新频率低一点，吃鸡准备阶段刷新频率低一点，不影响游戏效果