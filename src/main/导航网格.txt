导航网格寻路原理（NavMesh）
1、导航网格数据：表示游戏环境中可行走表面的数据结构，是由多个连接的多边形组成的网格，定义了角色可以行走的区域，适用于复杂的3D环境
2、寻路算法：
   Dijkstra算法
   A* 算法
   跳点搜索（JPS）
   Theta* 算法
   动态寻路算法
3、寻路过程
   首先，需要确定起点 a 和终点 b 分别位于哪个多边形内。这是寻路的基础，因为后续的路径计算都是基于这些多边形进行的
   寻找经过的 Poly ：如果起点和终点在同一个 Poly 内，那么它们之间的最短路径就是直线。如果不在同一个 Poly 内，就需要使用寻路算法（如 A* 算法）来计算从起点所在的 Poly 到终点所在的 Poly 需要经过哪些其他 Poly 。这一步骤会生成一个 Poly 的序列，表示路径从起点到终点需要经过的区域
   计算具体路径：有了经过的 Poly 序列后，接下来就是计算在这些 Poly 内部以及它们之间移动的具体路径。这通常涉及到计算 Poly 边界上的拐点，以及如何从一个 Poly 移动到另一个 Poly
   最终，这些点会被组织成一个数组，形成从起点到终点的具体移动路径

Recast Navigation
1、Recast Navigation 是一套开源的导航系统，用于生成导航网格和寻路。它包括多个功能，如 Recast 和 Detour
   Recast：用于导航网格的生成
   Detour：用于导航网格数据的运行时加载、寻路和导航网格的查询等。严格来说， Detour 可以用于任何导航网格数据的寻路，只是 Recast 生成的数据最适合，效果最好



GOAP : Goal-Oriented Action Planning
目标导向型行为计划 AI 算法
四个主要的类：
1、Agent代理：主体，负责连接各个类，主要逻辑在这里运行，游戏中可以是 Player、NPC 等具体的实现类
2、Action:动作： 可以被执行的动作，比如：拿东西、丢东西、吃饭、伐木等
  每个 Action 有需要有：执行的先决条件 preCondition，执行后的效果 effect
  每个 Action 的执行需要设定一个代价：Cost
3、IGoap: 数据提供者，提供给 Agent 目标和反馈是否成功失败等等，主要用于描述世界状态，简称环境变量、Agent 目标
4、Planer： 决策者， 通过各个类来决策出最优的路线供Agent使用

思路：
  每个Action执行后的效果是另一个Action的先决条件，通过这个逻辑串联一系列Action，从而找到达到最终目标的Action链条
  最终目标也是一个Action，达到最终目标可能有多个Action链条，通过计算链条总消耗来找到最优链条（A*算法）
  逆向寻找：「目标状态-->起始状态」，反向搜索，必定会包含目标状态，也一定会找到一条路（因为总会抵达一个当前已经符合的世界状态，否则就是设计的有问题了），只不过可能不是最短的。
难点：
  如何合理的定义每个Action的cost？
  如何合理抽象Action、condition和effect，并且把他们组成一张图
  何如设置目标Action、游戏不同阶段，目标Action可能不同
 总结：
  适合游戏步骤清晰的ai